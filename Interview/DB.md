# 운영체제

<details>
  <summary>Key에 대하여 설명해 주시고 종류에 대하여 설명해 주세요.</summary>
  <br>

- Key란 데이터베이스에서 검색, 정렬시 tuple을 구분할 수 있는 기준이 되는 Attribute입니다. 종류로는 Tuple을 유일하게 식별하기 위해 사용하는 속성들의 부분 집합의 후보키, 후보키 중 선택한 Main Key인 기본키, 다른 릴레이션의 기본키를 그대로 참조하는 속성의 집합의 외래키 등이 있습니다.
## Candidate Key (후보키)
- Tuple을 유일하게 식별하기 위해 사용하는 속성들의 부분 집합. (기본키로 사용할 수 있는 속성들)

    ### 2가지 조건 만족
    - 유일성 : Key로 하나의 Tuple을 유일하게 식별할 수 있음
    - 최소성 : 꼭 필요한 속성으로만 구성

## Primary Key (기본키)
- 후보키 중 선택한 Main Key

    ### 특징
    - Null 값을 가질 수 없음
    - 동일한 값이 중복될 수 없음

## Alternate Key (대체키)
- 후보키 중 기본키를 제외한 나머지 키 = 보조키


## Super Key (슈퍼키)
- 유일성은 만족하지만, 최소성은 만족하지 못하는 키


## Foreign Key (외래키)
- 다른 릴레이션의 기본키를 그대로 참조하는 속성의 집합

</details>

<details>
  <summary>정규화에 대하여 설명해 주세요.</summary>
  <br>

- 가장 큰 목표는 테이블 간 중복된 데이터를 허용하지 않는 것입니다.
- 정규화에는 여러가지 단계가 있지만, 대체적으로 1~3단계 정규화까지의 과정을 거칩니다.
## 제 1정규화(1NF)
- 테이블 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분리시키는 것을 말합니다.

## 제 2정규화(2NF)
- 테이블의 모든 컬럼이 완전 함수적 종속을 만족시키도록 하는 것입니다.

## 제 3정규화(3NF)
- 2NF가 진행된 테이블에서 이행적 종속을 없애기 위해 테이블을 분리하는 것입니다.

</details>

<details>
  <summary>SQL Injection에 대하여 설명해 주세요.</summary>
  <br>

- 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법입니다.

- 공격 방법
  - 인증 우회
  - 데이터 노출

- 방어 방법
  - input 값을 받을 때, 특수문자 여부 검사하기
  - SQL 서버 오류 발생 시, 해당하는 에러 메시지 감추기
  - preparestatement 사용하기
  
</details>

<details>
  <summary>트랜잭션에 대하여 설명해 주세요.</summary>
  <br>

- 트랜잭션이란 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위입니다.
- 특징으로는 `원자성(Atomicity)`, `일관성(Consistency)`, `독립성(Isolation)`, `지속성(Durability)`이 있습니다.
- 연산으로는 `Commit`, `RollBack`이 있습니다.
  
</details>

<details>
  <summary>트랜잭션 격리 수준(Transaction Isolation Level)에 대하여 설명해 주세요.</summary>
  <br>

- 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준입니다.

### 필요성
- 데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 하며 Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요합니다.
- 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 될 것이며 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생하게 됩니다.

### 종류
- `Read Uncommitted` (레벨 0)
  - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층
  - 트랜잭션에 처리중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함
  - 데이터베이스의 일관성을 유지하는 것이 불가능함
- `Read Committed` (레벨 1)
  - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층
  - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨
  - Commit이 이루어진 트랜잭션만 조회 가능
  - 대부분의 SQL 서버가 `Default`로 사용하는 Isolation Level임
- `Repeatable Read` (레벨 2)
  - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층
  - 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함
  - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능
  - MySQL에서 Default로 사용하는 Isolation Level
- `Serializable` (레벨 3)
  - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층
  - 완벽한 읽기 일관성 모드를 제공함
  - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능

### 선택 시 고려사항
- Isolation Level에 대한 조정은, 동시성과 데이터 무결성에 연관되어 있습니다.
- 동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 됩니다.
- 레벨을 높게 조정할 수록 발생하는 비용이 증가합니다.

</details>

<details>
  <summary>인덱스에 대하여 설명해 주세요.</summary>
  <br>

- 인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조입니다.
- 데이터베이스 안의 레코드를 처음부터 풀스캔하지 않고, B+ Tree로 구성된 구조에서 Index 파일 검색으로 속도를 향상시키는 기술입니다.
  
</details>

<details>
  <summary>SQL과 NOSQL에 대하여 각각 설명해 주시고 차이에 대하여 설명해 주세요.</summary>
  <br>

- SQL을 사용하면 RDBMS에서 데이터를 저장, 수정, 삭제 및 검색 할 수 있습니다.
- RDBMS에서 데이터는 테이블에 레코드로 저장되는데, 각 테이블마다 명확하게 정의된 구조가 있습니다. 따라서 스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없습니다.

- NoSQL은 주로 Not Only SQL을 칭합니다.
- NoSQL 데이터베이스(일명 "SQL만을 사용하지 않는 데이터베이스")는 표 형식이 아니며, 관계형 테이블과는 다른 방식으로 데이터를 저장합니다.
- NoSQL 데이터베이스는 데이터 모델에 따라 유형이 다양합니다. 주요 유형으로는 문서, 키 값, 와이드 컬럼, 그래프가 있고 이를 통하여 유연한 스키마를 제공하며, 대량의 데이터와 높은 사용자 부하에서도 손쉽게 확장이 가능합니다.

## SQL 장점
  - 명확하게 정의된 스키마, 데이터 무결성 보장
  - 관계는 각 데이터를 중복없이 한번만 저장
## SQL 단점
  - 덜 유연함. 데이터 스키마를 사전에 계획하고 알려야 함. (나중에 수정하기 힘듬)
  - 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음
  - 대체로 수직적 확장만 가능함
## NoSQL 장점
  - 스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능
  - 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨. 데이터 읽어오는 속도 빨라짐
  - 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능
## NoSQL 단점
  - 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
  - 데이터 중복을 계속 업데이트 해야 함
  - 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)

## SQL 데이터베이스 사용이 더 좋을 때
- 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우(NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율적)
- 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우

## NoSQL 데이터베이스 사용이 더 좋을 때
- 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우
- 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
- 데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)


### Scale-Up vs Scale-Out
- 수직적 확장(Scale-Up) : 단순히 데이터베이스 서버의 성능을 향상시키는 것 (ex. CPU 업그레이드)
- 수평적 확장(Scale-Out) : 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미 (하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동)

</details>

<details>
  <summary>ORM에 대하여 설명해 주세요.</summary>
  <br>

- Object Relational Mapping의 약자로 객체와 데이터베이스의 관계를 매핑해주는 도구입니다.
- 종류로는 TypeORM, Sequelize, SQLAlchemy 등이 있습니다.

### 장점
- 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와줍니다.
- 재사용 및 유지보수의 편리성이 증가합니다.
- DBMS에 대한 종속성이 줄어듭니다.

### 단점
- ORM 으로만 완벽한 서비스를 구현하기가 어렵습니다.
  - 사용하기는 편하지만 설계는 매우 신중하게 해야합니다.
  - 프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있습니다.
  - 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있습니다.
  - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우가 있습니다.
- 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵습니다.

</details>

<details>
  <summary>저장 프로시저(Stored PROCEDURE)에 대하여 설명해 주세요.</summary>
  <br>

- 일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합입니다.
- 프로시저를 만들어두면, 애플리케이션에서 여러 상황에 따라 해당 쿼리문이 필요할 때 인자 값만 전달하여 쉽게 원하는 결과물을 받아낼 수 있습니다.

### 장점
- 최적화 & 캐시
  - 프로시저의 최초 실행 시 최적화 상태로 컴파일이 되며, 그 이후 프로시저 캐시에 저장됩니다.
  - 만약 해당 프로세스가 여러번 사용될 때, 다시 컴파일 작업을 거치지 않고 캐시에서 가져오게 됩니다.

- 유지 보수
  - 작업이 변경될 때, 다른 작업은 건드리지 않고 프로시저 내부에서 수정만 하면 됩니다. (But, 장점이 단점이 될 수도 있는 부분이기도.. )

- 트래픽 감소
  - 클라이언트가 직접 SQL문을 작성하지 않고, 프로시저명에 매개변수만 담아 전달하면 됩니다. 즉, SQL문이 서버에 이미 저장되어 있기 때문에 클라이언트와 서버 간 네트워크 상 트래픽이 감소됩니다.

- 보안
  - 프로시저 내에서 참조 중인 테이블의 접근을 막을 수 있다.

### 단점
- 호환성
  - 구문 규칙이 SQL / PSM 표준과의 호환성이 낮기 때문에 코드 자산으로의 재사용성이 나쁩니다.

- 성능
  - 문자 또는 숫자 연산에서 프로그래밍 언어인 C나 Java보다 성능이 느립니다.

- 디버깅
  - 에러가 발생했을 때, 어디서 잘못됐는지 디버깅하는 것이 힘들 수 있습니다.

### Reference
- [저장 프로시저(Stored PROCEDURE)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/%EC%A0%80%EC%9E%A5%20%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80(Stored%20PROCEDURE).md)
- [저장 프로시저 wiki](https://ko.wikipedia.org/wiki/%EC%A0%80%EC%9E%A5_%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80)
</details>